"""
Создайте декоратор, который кэширует (сохраняет для дальнейшего использования)
результаты вызова функции и, при повторном вызове с теми же аргументами,
возвращает сохранённый результат.
Примените его к рекурсивной функции вычисления чисел Фибоначчи.
В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и,
если такие аргументы уже использовались, должен вернуть сохранённый результат
вместо запуска расчёта.
"""


def cache(func):
    """
    Декоратор для кэширования результатов вызова функции.
    Если функция вызывается с теми же аргументами, возвращается кэшированный результат.
    """
    cache_dict = {}  # Словарь для хранения кэшированных значений

    def wrapper(*args, **kwargs):
        # Если результат для этих аргументов уже есть в кэше, возвращаем его
        if args in cache_dict:
            print(f"Результат для {args} найден в кэше.")
            return cache_dict[args]

        # Иначе вызываем оригинальную функцию и сохраняем результат в кэш
        result = func(*args, **kwargs)
        cache_dict[args] = result
        return result

    return wrapper


# Применяем декоратор к функции Фибоначчи
@cache
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)


# Пример использования
print(fibonacci(10))  # Вызовет вычисление
print(fibonacci(10))  # Возьмёт из кэша
print(fibonacci(5))  # Вызовет вычисление
print(fibonacci(5))  # Возьмёт из кэша
